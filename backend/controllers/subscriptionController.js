import {
  User,
  Subscription,
  Payment,
  SubscriptionPlan,
} from "../models/index.js";
import crypto from "crypto";
import adminNotificationController from "./admin/notificationController.js";
import userNotificationController from "./user/notificationController.js";
import CashfreeService from "../services/cashfreeService.js";

// Initialize Cashfree service
const cashfreeService = new CashfreeService();

const subscriptionController = {
  // Get subscription plans
  getPlans: async (req, res) => {
    try {
      // Only return active plans for regular users
      const plans = await SubscriptionPlan.find({ isActive: true }).sort({
        price: 1,
      });

      res.status(200).json({
        success: true,
        data: plans,
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error fetching plans",
      });
    }
  },

  // Create payment order
  createOrder: async (req, res) => {
    try {
      const { planId } = req.body;
      const userId = req.user.id;

      console.log("Starting order creation with planId:", planId);

      // Validate planId
      if (!planId) {
        return res.status(400).json({
          success: false,
          message: "Plan ID is required",
        });
      }

      // Get plan details from SubscriptionPlan model
      const plan = await SubscriptionPlan.findById(planId);
      console.log("Found plan:", plan);

      if (!plan || !plan.isActive) {
        return res.status(400).json({
          success: false,
          message: "Invalid or inactive plan",
        });
      }

      // Check if user already has an active subscription
      const activeSubscription = await Subscription.findOne({
        userId,
        expiryDate: { $gt: new Date() },
      });

      if (activeSubscription) {
        return res.status(400).json({
          success: false,
          message: "User already has an active subscription",
        });
      }

      // Get user details
      const user = await User.findById(userId);
      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      try {
        // Try payment link approach first (similar to the test app)
        // This method avoids phone validation issues as Cashfree will handle it
        const linkDetails = {
          amount: plan.price,
          currency: "INR",
          userId: userId.toString(),
          customerName: user.name || "YuMix User",
          customerEmail: user.email || "user@example.com",
          // Phone is not required for initial setup, Cashfree will ask during payment
          customerPhone: user.phone || "",
          note: `Payment for ${plan.name} subscription`,
        };

        console.log("Creating Cashfree payment link:", linkDetails);

        const linkResult = await cashfreeService.createPaymentLink(linkDetails);

        if (!linkResult.success) {
          console.error("Error creating payment link:", linkResult.error);

          // More specific error message
          let errorMessage = "Failed to create payment link";
          if (linkResult.error) {
            errorMessage = `Payment gateway error: ${linkResult.error}`;
          }

          return res.status(400).json({
            success: false,
            message: errorMessage,
            details: linkResult,
          });
        }

        console.log("Cashfree payment link created:", linkResult);

        if (!linkResult.paymentLink) {
          return res.status(400).json({
            success: false,
            message: "Payment link not generated by Cashfree",
            details: linkResult,
          });
        }

        // Create subscription record
        const subscription = new Subscription({
          userId,
          planType: plan.name,
          amount: plan.price,
          startDate: new Date(),
          expiryDate: new Date(
            Date.now() + plan.duration * 24 * 60 * 60 * 1000
          ),
          paymentStatus: "pending",
        });
        await subscription.save();

        // Create payment record
        const payment = new Payment({
          userId,
          subscriptionId: subscription._id,
          amount: plan.price,
          paymentMethod: "cashfree",
          cashfreeLinkId: linkResult.linkId,
          status: "pending",
        });
        await payment.save();

        // Prepare response with Cashfree payment link data
        const responseData = {
          success: true,
          data: {
            linkId: linkResult.linkId,
            amount: plan.price,
            currency: "INR",
            subscriptionId: subscription._id,
            paymentId: payment._id,
            paymentLink: linkResult.paymentLink,
            appId: process.env.CASHFREE_APP_ID,
          },
        };

        res.status(200).json(responseData);
      } catch (gatewayError) {
        console.error("Cashfree Payment Gateway Error:", {
          message: gatewayError.message,
          stack: gatewayError.stack,
          details: gatewayError,
        });

        return res.status(500).json({
          success: false,
          message: "Error creating Cashfree payment",
          error: gatewayError.message,
          details: "Please check server logs for more information",
        });
      }
    } catch (error) {
      console.error("Order Creation Error:", error);
      res.status(500).json({
        success: false,
        message: "Error creating order",
        error: error.message,
      });
    }
  },

  // Verify payment
  verifyPayment: async (req, res) => {
    try {
      console.log("Payment verification request:", req.body);
      const { orderId, linkId, subscriptionId, paymentId } = req.body;
      const userId = req.user.id;

      // Validate that we have at least one of the required IDs
      if (!orderId && !linkId) {
        return res.status(400).json({
          success: false,
          message:
            "Missing payment reference. Please provide either orderId or linkId.",
        });
      }

      console.log(`Verifying payment for user ${userId}:`, {
        orderId,
        linkId,
        subscriptionId,
        paymentId,
      });

      // Create a new instance of CashfreeService
      const cashfreeService = new CashfreeService();

      let paymentStatus;
      let paymentData;
      let verified = false;

      // Check if we have an order ID (direct payment)
      if (orderId) {
        console.log(`Checking order status for orderId: ${orderId}`);
        const orderStatus = await cashfreeService.getPaymentStatus(orderId);

        if (orderStatus.success) {
          console.log(`Order status for ${orderId}:`, orderStatus);
          paymentStatus = orderStatus.status;
          paymentData = orderStatus.data;

          // Check if payment is marked as PAID
          if (paymentStatus === "PAID") {
            console.log(`Order ${orderId} is marked as PAID`);
            verified = true;
          }
        } else {
          console.log(
            `Failed to get order status for ${orderId}:`,
            orderStatus
          );
        }
      }

      // If not verified with order ID, check payment link
      if (!verified && linkId) {
        console.log(`Checking payment link status for linkId: ${linkId}`);
        const linkStatus = await cashfreeService.getPaymentLinkStatus(linkId);

        if (linkStatus.success) {
          console.log(`Payment link status for ${linkId}:`, linkStatus);
          paymentStatus = linkStatus.status;
          paymentData = linkStatus.data;

          // Check if link is marked as PAID
          if (paymentStatus === "PAID") {
            console.log(`Payment link ${linkId} is marked as PAID`);
            verified = true;
          }
        } else {
          console.log(`Failed to get link status for ${linkId}:`, linkStatus);
        }
      }

      // If payment is verified, update the subscription
      if (verified) {
        console.log(`Payment verified for user ${userId}`);

        try {
          // Check if we have a valid subscriptionId
          if (!subscriptionId) {
            console.warn("No subscriptionId provided for verified payment");
            return res.status(400).json({
              success: false,
              message: "Missing subscription reference.",
            });
          }

          // Find the subscription
          const subscription = await Subscription.findById(subscriptionId);
          if (!subscription) {
            console.warn(`Subscription not found: ${subscriptionId}`);
            return res.status(404).json({
              success: false,
              message: "Subscription not found.",
            });
          }

          // Find the user
          const user = await User.findById(userId);
          if (!user) {
            console.warn(`User not found: ${userId}`);
            return res.status(404).json({
              success: false,
              message: "User not found.",
            });
          }

          // Find the payment record if we have a paymentId
          let payment;
          if (paymentId) {
            payment = await Payment.findById(paymentId);
            if (!payment) {
              console.warn(`Payment record not found: ${paymentId}`);
            } else {
              // Update payment status
              payment.status = "completed";
              payment.cashfreeReferenceId =
                paymentData.cf_payment_id ||
                paymentData.order_id ||
                paymentData.link_id;
              payment.paymentDetails = {
                ...payment.paymentDetails,
                verifiedAt: new Date(),
                verificationData: paymentData,
              };
              await payment.save();
              console.log(`Payment record updated: ${paymentId}`);
            }
          }

          // Update subscription status if not already active
          if (subscription.paymentStatus !== "completed") {
            subscription.paymentStatus = "completed";
            await subscription.save();
            console.log(`Subscription ${subscriptionId} marked as completed`);
          } else {
            console.log(
              `Subscription ${subscriptionId} was already marked as completed`
            );
          }

          // Update user subscription details if not already subscribed
          if (!user.isSubscribed) {
            user.isSubscribed = true;
            user.subscriptionId = subscription._id;
            user.subscriptionExpiryDate = subscription.expiryDate;
            await user.save();
            console.log(
              `User ${userId} marked as subscribed with expiry date ${subscription.expiryDate}`
            );
          } else {
            console.log(`User ${userId} was already marked as subscribed`);
          }

          // Return success response
          return res.json({
            success: true,
            message: "Payment verified successfully",
          });
        } catch (dbError) {
          console.error("Database error updating subscription:", dbError);
          return res.status(500).json({
            success: false,
            message: "Error updating subscription data after verification",
            error: dbError.message,
          });
        }
      } else {
        // If payment was not verified, return appropriate status
        console.log(`Payment not verified for user ${userId}:`, {
          status: paymentStatus,
          orderId,
          linkId,
        });

        // Determine specific error message based on payment status
        let errorMessage = "Payment could not be verified";

        if (paymentStatus === "ACTIVE") {
          errorMessage =
            "Payment is still pending. Please complete your payment.";
        } else if (
          paymentStatus === "CANCELLED" ||
          paymentStatus === "FAILED"
        ) {
          errorMessage = "Payment was cancelled or failed. Please try again.";
        } else if (paymentStatus === "EXPIRED") {
          errorMessage =
            "Payment session has expired. Please create a new order.";
        }

        return res.status(402).json({
          success: false,
          message: errorMessage,
          status: paymentStatus || "UNKNOWN",
        });
      }
    } catch (error) {
      console.error("Error verifying payment:", error);
      return res.status(500).json({
        success: false,
        message: "Failed to verify payment",
        error: error.message,
      });
    }
  },

  // Get subscription status
  getStatus: async (req, res) => {
    try {
      const user = await User.findById(req.user.id).populate("subscriptionId");

      if (!user.isSubscribed) {
        return res.status(200).json({
          success: true,
          data: {
            isSubscribed: false,
            subscription: null,
          },
        });
      }

      res.status(200).json({
        success: true,
        data: {
          isSubscribed: true,
          subscription: user.subscriptionId,
        },
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        message: "Error fetching subscription status",
        error: error.message,
      });
    }
  },

  // Handle payment gateway webhook
  handleWebhook: async (req, res) => {
    try {
      console.log(
        "Received Cashfree webhook:",
        JSON.stringify(req.body, null, 2)
      );
      console.log("Webhook headers:", JSON.stringify(req.headers, null, 2));

      // Verify webhook signature
      const signature =
        req.headers["x-webhook-signature"] ||
        req.headers["x-cashfree-signature"];

      if (!signature) {
        console.warn("Missing Cashfree webhook signature header");
        // Continue processing even without signature for testing
        console.log("TESTING MODE: Continuing without signature verification");
      } else {
        // Verify the webhook signature
        const rawBody =
          typeof req.body === "string" ? req.body : JSON.stringify(req.body);
        const isValid = cashfreeService.verifyWebhookSignature(
          rawBody,
          signature
        );

        if (!isValid) {
          console.warn("Invalid Cashfree webhook signature");
          console.log("TESTING MODE: Continuing with invalid signature");
        }
      }

      // Process different event types
      const { event_type, data } = req.body;
      console.log(`Processing Cashfree webhook event: ${event_type}`);

      // Extract essential data for debugging
      if (data) {
        const orderId = data.order?.order_id || data.order_id || "unknown";
        const linkId = data.link?.link_id || data.link_id || "unknown";
        const amount = data.order?.order_amount || data.amount || "unknown";
        console.log(
          `Webhook details: Type=${event_type}, OrderID=${orderId}, LinkID=${linkId}, Amount=${amount}`
        );
      }

      switch (event_type) {
        case "ORDER_PAID":
          // Handle successful payment for orders
          await handleOrderPaid(data);
          break;

        case "PAYMENT_SUCCESS":
          // Alternative event for successful payment
          await handlePaymentSuccess(data);
          break;

        case "LINK_PAID":
          // Handle successful payment for payment links
          await handleLinkPaid(data);
          break;

        case "ORDER_FAILED":
        case "PAYMENT_FAILED":
        case "LINK_FAILED":
          // Handle failed payment
          await handlePaymentFailed(data, req.admin);
          break;

        // Handle unknown events by trying to process as success for testing
        default:
          console.log(
            `Unhandled Cashfree webhook event: ${event_type} - attempting to process as payment success for testing`
          );

          // Try to extract payment data in various formats
          const linkId = data?.link?.link_id || data?.link_id;
          const orderId = data?.order?.order_id || data?.order_id;

          if (linkId) {
            console.log(
              `Treating unknown event as LINK_PAID for linkId: ${linkId}`
            );
            await handleLinkPaid(data);
          } else if (orderId) {
            console.log(
              `Treating unknown event as ORDER_PAID for orderId: ${orderId}`
            );
            await handleOrderPaid(data);
          } else {
            console.log(
              `Unable to process unknown event type, no linkId or orderId found`
            );
          }
      }

      // Add a manual check for recent payments that might need notifications
      try {
        console.log(
          "Performing additional check for recent completed payments..."
        );
        const twentyMinutesAgo = new Date(Date.now() - 20 * 60 * 1000);

        const recentCompletedPayments = await Payment.find({
          status: "completed",
          updatedAt: { $gte: twentyMinutesAgo },
          // Only find payments that were updated recently
        }).populate("userId");

        console.log(
          `Found ${recentCompletedPayments.length} recent completed payments`
        );

        for (const payment of recentCompletedPayments) {
          // Check if this payment has a subscription
          if (payment.subscriptionId) {
            const subscription = await Subscription.findById(
              payment.subscriptionId
            );
            if (subscription && subscription.paymentStatus === "completed") {
              console.log(
                `Found recent completed payment: ${payment._id} for user: ${
                  payment.userId?._id || payment.userId
                }`
              );

              // Get user details
              const user = payment.userId;
              if (user && typeof user !== "string") {
                console.log(
                  `Processing subscription notification for user: ${
                    user.name || user._id
                  }`
                );

                // Get all active admins
                const { Admin } = await import("../models/index.js");
                const admins = await Admin.find({ status: "active" });
                console.log(
                  `Found ${admins.length} active admins to notify about recent payment`
                );

                // Send notifications to all admins
                for (const admin of admins) {
                  try {
                    const notification =
                      await adminNotificationController.createAdminNotification(
                        {
                          adminId: admin._id,
                          title: "Recent Subscription Detected",
                          message: `${user.name} subscribed to ${subscription.planType} plan for ₹${payment.amount}`,
                          type: "subscription",
                          data: {
                            userId: user._id,
                            userName: user.name,
                            userEmail: user.email,
                            planType: subscription.planType,
                            amount: payment.amount,
                            subscriptionId: subscription._id,
                            timestamp: new Date(),
                            manualCheck: true,
                          },
                        }
                      );

                    if (notification) {
                      console.log(
                        `Successfully created notification for admin ${admin._id} from manual check`
                      );
                    }
                  } catch (err) {
                    console.error(
                      `Error creating notification for admin ${admin._id}:`,
                      err
                    );
                  }
                }
              }
            }
          }
        }
      } catch (extraCheckError) {
        console.error("Error during extra payment check:", extraCheckError);
      }

      // Acknowledge receipt of webhook
      res.status(200).json({ status: "ok" });
    } catch (error) {
      console.error("Cashfree Webhook Error:", error);
      console.error(error.stack);
      res
        .status(500)
        .json({ message: "Webhook processing failed", error: error.message });
    }
  },

  // Get detailed subscription status
  getSubscriptionStatus: async (req, res) => {
    try {
      const userId = req.user.id;
      console.log(`Getting subscription status for user: ${userId}`);

      // Find the user with populated subscription
      const user = await User.findById(userId);

      if (!user) {
        return res.status(404).json({
          success: false,
          message: "User not found",
        });
      }

      let isSubscribed = user.isSubscribed || false;
      let subscriptionData = null;
      let plan = null;
      let expiryDate = null;

      // If user is marked as subscribed, fetch their subscription details
      if (isSubscribed) {
        console.log(
          `User ${userId} is marked as subscribed, fetching subscription details`
        );

        // Fetch the subscription details
        const subscription = await Subscription.findById(
          user.subscriptionId
        ).exec();

        if (!subscription) {
          console.warn(
            `User ${userId} is marked as subscribed but no subscription found`
          );
          isSubscribed = false; // Correct the inconsistency
        } else {
          subscriptionData = subscription;
          expiryDate = subscription.expiryDate;

          // Fetch the plan details
          if (subscription.planId) {
            plan = await SubscriptionPlan.findById(subscription.planId).exec();

            if (!plan) {
              console.warn(
                `Subscription ${subscription._id} references non-existent plan ${subscription.planId}`
              );

              // Try to find the plan by type as a fallback
              if (subscription.planType) {
                console.log(
                  `Attempting to find plan by type: ${subscription.planType}`
                );
                plan = await SubscriptionPlan.findOne({
                  name: subscription.planType,
                }).exec();

                if (!plan) {
                  console.warn(
                    `Could not find plan with name: ${subscription.planType}`
                  );
                }
              }
            }
          } else if (subscription.planType) {
            // If planId is missing but we have planType, try to find by name
            plan = await SubscriptionPlan.findOne({
              name: subscription.planType,
            }).exec();

            if (!plan) {
              console.warn(
                `Could not find plan with name: ${subscription.planType}`
              );
            }
          }

          // If still no plan found, create a minimal plan object with available data
          if (!plan && isSubscribed) {
            console.warn(
              `Creating minimal plan object for subscribed user ${userId}`
            );
            plan = {
              _id: subscription._id, // Use subscription ID as fallback
              name: subscription.planType || "Premium Plan",
              planType: subscription.planType || "Premium Plan",
              maxSearchesPerDay: subscription.maxSearches || 30,
              isActive: true,
            };
          }
        }
      }

      // Calculate remaining searches
      const dailySearchCount = user.dailySearchCount || 0;
      const maxSearches = plan ? plan.maxSearchesPerDay || 30 : 3;
      const remainingSearches = isSubscribed
        ? plan.maxSearchesPerDay === -1
          ? Infinity
          : Math.max(0, maxSearches - dailySearchCount)
        : Math.max(0, 3 - dailySearchCount);

      // Log the status for debugging
      console.log(`Subscription status for user ${userId}:`, {
        isSubscribed,
        planId: plan?._id || null,
        planName: plan?.name || null,
        expiryDate,
        remainingSearches,
        maxSearches,
      });

      // Ensure data consistency - if subscribed but no plan, this is an error state
      if (isSubscribed && !plan) {
        console.error(
          `Inconsistent state: User ${userId} is subscribed but no plan data is available`
        );
        // We'll still return isSubscribed=true but log the error
      }

      res.status(200).json({
        success: true,
        data: {
          isSubscribed,
          plan,
          expiryDate,
          remainingSearches,
          maxSearches,
        },
      });
    } catch (error) {
      console.error("Error fetching subscription status:", error);
      res.status(500).json({
        success: false,
        message: "Error fetching subscription status",
        error: error.message,
      });
    }
  },
};

// Helper functions for webhook processing
async function handleOrderPaid(data) {
  const order = data.order;
  console.log("Processing ORDER_PAID webhook for order:", order.order_id);

  // Find payment with matching cashfreeOrderId
  const payment = await Payment.findOne({
    cashfreeOrderId: order.order_id,
  });

  if (!payment) {
    console.warn(`Payment not found for Cashfree order ID: ${order.order_id}`);
    return;
  }

  // Update payment status
  payment.status = "completed";
  payment.cashfreeReferenceId =
    data.payment?.cf_payment_id || order.reference_id;
  payment.cashfreePaymentId = data.payment?.cf_payment_id || order.reference_id;
  payment.paymentDetails = data;
  await payment.save();

  console.log(`Updated payment status for ID: ${payment._id} to completed`);

  // Update subscription
  const subscription = await Subscription.findById(payment.subscriptionId);
  if (subscription) {
    subscription.paymentStatus = "completed";
    await subscription.save();

    // Update user
    await User.findByIdAndUpdate(payment.userId, {
      isSubscribed: true,
      subscriptionId: subscription._id,
    });

    console.log(
      `Updated subscription status for ID: ${subscription._id} to completed`
    );

    // Get user details for notifications
    const user = await User.findById(payment.userId);

    // Create user notification
    if (user) {
      await userNotificationController.createUserNotification({
        userId: user._id,
        title: "Subscription Activated",
        message: `Your subscription to ${subscription.planType} has been activated`,
        type: "subscription",
        data: {
          planId: subscription._id,
        },
      });

      // Notify admins about new subscription
      try {
        console.log(
          "Sending admin notifications for new subscription from ORDER_PAID"
        );
        // Get all active admins
        const { Admin } = await import("../models/index.js");
        const admins = await Admin.find({ status: "active" });
        console.log(`Found ${admins.length} active admins to notify`);

        // Create notification for each admin
        let notificationCount = 0;
        for (const admin of admins) {
          console.log(
            `Processing notification for admin: ${admin._id}, Preferences:`,
            admin.preferences
          );
          const notification =
            await adminNotificationController.createAdminNotification({
              adminId: admin._id,
              title: "New Subscription",
              message: `${user.name} subscribed to ${subscription.planType} plan for ₹${payment.amount}`,
              type: "subscription",
              data: {
                userId: user._id,
                userName: user.name,
                userEmail: user.email,
                planType: subscription.planType,
                amount: payment.amount,
                subscriptionId: subscription._id,
                timestamp: new Date(),
              },
            });

          if (notification) {
            notificationCount++;
            console.log(
              `Created admin notification for ${admin._id}: ${notification._id}`
            );
          } else {
            console.log(
              `Failed to create notification for admin ${admin._id} - likely due to preferences`
            );
          }
        }
        console.log(
          `Successfully sent ${notificationCount} admin notifications`
        );
      } catch (notificationError) {
        console.error("Error sending admin notifications:", notificationError);
      }
    }
  }
}

async function handlePaymentSuccess(data) {
  // This is an alternative event that might be sent by Cashfree
  // The structure might be different from ORDER_PAID
  const orderId = data.order?.order_id || data.order_id;

  if (!orderId) {
    console.warn("No order ID found in Cashfree PAYMENT_SUCCESS webhook");
    return;
  }

  // Find payment with matching cashfreeOrderId
  const payment = await Payment.findOne({ cashfreeOrderId: orderId });

  if (!payment) {
    console.warn(`Payment not found for Cashfree order ID: ${orderId}`);
    return;
  }

  // Process the payment same as ORDER_PAID
  payment.status = "completed";
  payment.cashfreeReferenceId =
    data.payment?.cf_payment_id || data.reference_id;
  payment.cashfreePaymentId = data.payment?.cf_payment_id || data.reference_id;
  payment.paymentDetails = data;
  await payment.save();

  // Continue with subscription and user updates as in handleOrderPaid...
  const subscription = await Subscription.findById(payment.subscriptionId);
  if (subscription) {
    subscription.paymentStatus = "completed";
    await subscription.save();

    await User.findByIdAndUpdate(payment.userId, {
      isSubscribed: true,
      subscriptionId: subscription._id,
    });
  }
}

// Handle payment link paid event
async function handleLinkPaid(data) {
  const linkId = data.link?.link_id || data.link_id;

  if (!linkId) {
    console.warn("No link ID found in Cashfree LINK_PAID webhook");
    return;
  }

  console.log(`Processing payment for link ID: ${linkId}`);

  // Find payment with matching cashfreeLinkId
  const payment = await Payment.findOne({ cashfreeLinkId: linkId });

  if (!payment) {
    console.warn(`Payment not found for Cashfree link ID: ${linkId}`);
    return;
  }

  // Update payment status
  payment.status = "completed";
  payment.cashfreeReferenceId = data.transaction_id || data.reference_id || "";
  payment.paymentDetails = data;
  await payment.save();

  console.log(`Updated payment status for ID: ${payment._id} to completed`);

  // Update subscription status
  const subscription = await Subscription.findById(payment.subscriptionId);
  if (subscription) {
    subscription.paymentStatus = "completed";
    await subscription.save();

    console.log(
      `Updated subscription status for ID: ${subscription._id} to completed`
    );

    // Update user subscription status
    await User.findByIdAndUpdate(payment.userId, {
      isSubscribed: true,
      subscriptionId: subscription._id,
    });

    // Get user details for notifications
    const user = await User.findById(payment.userId);

    // Create user notification
    if (user) {
      await userNotificationController.createUserNotification({
        userId: user._id,
        title: "Subscription Activated",
        message: `Your subscription to ${subscription.planType} has been activated`,
        type: "subscription",
        data: {
          planId: subscription._id,
        },
      });

      // Notify admins about new subscription
      try {
        console.log(
          "Sending admin notifications for new subscription from LINK_PAID"
        );
        // Get all active admins
        const { Admin } = await import("../models/index.js");
        const admins = await Admin.find({ status: "active" });
        console.log(`Found ${admins.length} active admins to notify`);

        // Create notification for each admin
        let notificationCount = 0;
        for (const admin of admins) {
          console.log(
            `Processing notification for admin: ${admin._id}, Preferences:`,
            admin.preferences
          );
          const notification =
            await adminNotificationController.createAdminNotification({
              adminId: admin._id,
              title: "New Subscription",
              message: `${user.name} subscribed to ${subscription.planType} plan for ₹${payment.amount}`,
              type: "subscription",
              data: {
                userId: user._id,
                userName: user.name,
                userEmail: user.email,
                planType: subscription.planType,
                amount: payment.amount,
                subscriptionId: subscription._id,
                timestamp: new Date(),
              },
            });

          if (notification) {
            notificationCount++;
            console.log(
              `Created admin notification for ${admin._id}: ${notification._id}`
            );
          } else {
            console.log(
              `Failed to create notification for admin ${admin._id} - likely due to preferences`
            );
          }
        }
        console.log(
          `Successfully sent ${notificationCount} admin notifications`
        );
      } catch (notificationError) {
        console.error("Error sending admin notifications:", notificationError);
        console.error(notificationError.stack);
      }
    }
  }
}

async function handlePaymentFailed(data, admin) {
  const orderId = data.order?.order_id || data.order_id;
  const linkId = data.link?.link_id || data.link_id;

  if (!orderId && !linkId) {
    console.warn("No order/link ID found in Cashfree payment failed webhook");
    return;
  }

  // Find payment with matching ID based on the type
  let payment;
  if (orderId) {
    payment = await Payment.findOne({ cashfreeOrderId: orderId }).populate(
      "userId"
    );
  } else if (linkId) {
    payment = await Payment.findOne({ cashfreeLinkId: linkId }).populate(
      "userId"
    );
  }

  if (!payment) {
    console.warn(`Payment not found for Cashfree ID: ${orderId || linkId}`);
    return;
  }

  // Update payment status
  payment.status = "failed";
  payment.paymentDetails = data;
  await payment.save();

  console.log(`Updated payment status for ID: ${payment._id} to failed`);

  // Notify admin if available
  if (admin && admin._id) {
    const user = await User.findById(payment.userId);

    await adminNotificationController.createAdminNotification({
      adminId: admin._id,
      title: "Payment Failed",
      message: `Payment failed: ₹${payment.amount} from ${
        user?.name || "unknown user"
      }`,
      type: "payment",
      data: {
        userId: payment.userId,
        amount: payment.amount,
        paymentId: payment._id,
        status: "failed",
        timestamp: new Date(),
      },
    });
  }
}

// Get all subscription plans
export const getAllPlans = async (req, res) => {
  try {
    const plans = await SubscriptionPlan.find({ isActive: true })
      .sort("order")
      .select("-__v");

    res.status(200).json({
      success: true,
      data: plans,
    });
  } catch (error) {
    console.error("Error getting plans:", error);
    res.status(500).json({
      success: false,
      message: "Failed to get subscription plans",
    });
  }
};

// Create a new subscription plan
export const createPlan = async (req, res) => {
  try {
    const activePlans = await SubscriptionPlan.countDocuments({
      isActive: true,
    });
    if (activePlans >= 3) {
      return res.status(400).json({
        success: false,
        message: "Maximum number of active plans (3) reached",
      });
    }

    // Check if plan with same order exists
    const existingPlan = await SubscriptionPlan.findOne({
      order: req.body.order,
      isActive: true,
    });
    if (existingPlan) {
      return res.status(400).json({
        success: false,
        message: `A plan with order ${req.body.order} already exists`,
      });
    }

    // Get admin ID from either req.user or req.admin
    const adminId = req.user?._id || req.admin?._id;
    if (!adminId) {
      return res.status(401).json({
        success: false,
        message: "Admin authentication required",
      });
    }

    const plan = await SubscriptionPlan.create({
      ...req.body,
      createdBy: adminId,
    });

    res.status(201).json({
      success: true,
      data: plan,
    });
  } catch (error) {
    console.error("Error creating plan:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to create subscription plan",
    });
  }
};

// Update a subscription plan
export const updatePlan = async (req, res) => {
  try {
    const { id } = req.params;

    // Check if changing order and if new order conflicts
    if (req.body.order) {
      const existingPlan = await SubscriptionPlan.findOne({
        order: req.body.order,
        isActive: true,
        _id: { $ne: id },
      });
      if (existingPlan) {
        return res.status(400).json({
          success: false,
          message: `A plan with order ${req.body.order} already exists`,
        });
      }
    }

    const plan = await SubscriptionPlan.findByIdAndUpdate(
      id,
      { ...req.body },
      { new: true, runValidators: true }
    );

    if (!plan) {
      return res.status(404).json({
        success: false,
        message: "Subscription plan not found",
      });
    }

    res.status(200).json({
      success: true,
      data: plan,
    });
  } catch (error) {
    console.error("Error updating plan:", error);
    res.status(500).json({
      success: false,
      message: error.message || "Failed to update subscription plan",
    });
  }
};

// Delete a subscription plan
export const deletePlan = async (req, res) => {
  try {
    const { id } = req.params;

    // Count active plans
    const activePlans = await SubscriptionPlan.countDocuments({
      isActive: true,
    });
    if (activePlans <= 1) {
      return res.status(400).json({
        success: false,
        message: "Cannot delete the last active plan",
      });
    }

    // Actually delete the plan from database
    const plan = await SubscriptionPlan.findByIdAndDelete(id);

    if (!plan) {
      return res.status(404).json({
        success: false,
        message: "Subscription plan not found",
      });
    }

    res.status(200).json({
      success: true,
      message: "Plan permanently deleted",
    });
  } catch (error) {
    console.error("Error deleting plan:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete subscription plan",
    });
  }
};

// Initialize default plans if none exist
export const initializeDefaultPlans = async (req, res) => {
  try {
    const activePlans = await SubscriptionPlan.countDocuments({
      isActive: true,
    });
    if (activePlans > 0) {
      return res.status(400).json({
        success: false,
        message: "Active plans already exist",
      });
    }

    const defaultPlans = [
      {
        name: "Basic Plan",
        price: 99,
        duration: 30,
        features: [
          "Access to basic recipes",
          "Save favorite recipes",
          "10 recipe searches per day",
          "Basic meal planning",
        ],
        maxSearchesPerDay: 10,
        order: 1,
        createdBy: req.user._id,
      },
      {
        name: "Premium Plan",
        price: 199,
        duration: 30,
        features: [
          "All Basic features",
          "Advanced recipe suggestions",
          "25 recipe searches per day",
          "Personalized meal plans",
          "Priority support",
        ],
        maxSearchesPerDay: 25,
        order: 2,
        createdBy: req.user._id,
      },
      {
        name: "Pro Plan",
        price: 299,
        duration: 30,
        features: [
          "All Premium features",
          "Unlimited recipe searches",
          "Professional cooking tools",
          "Custom recipe creation",
          "24/7 priority support",
          "Recipe analytics",
        ],
        maxSearchesPerDay: -1, // -1 indicates unlimited
        order: 3,
        createdBy: req.user._id,
      },
    ];

    await SubscriptionPlan.create(defaultPlans);

    res.status(201).json({
      success: true,
      message: "Default plans initialized successfully",
    });
  } catch (error) {
    console.error("Error initializing default plans:", error);
    res.status(500).json({
      success: false,
      message: "Failed to initialize default plans",
    });
  }
};

export default subscriptionController;
